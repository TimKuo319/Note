
## 引號

- 單引號用來表示字串
- 雙引號用來表示識別符號或者是需要區分大小寫的字串

```sql
-- 實際上會去搜尋 user table 中的 username(自動改為小寫)
SELECT USERNAME FROM USER;
```

```sql
-- 會去找 User 表中的 Useraname(依照雙引號內的字)
SELECT "Username" FROM "User";
```

*註 : MySQL 中單/雙引號都可以用來表示字串，基本上不區分大小寫，且是用反引號來表示識別符號*

## 自動增加欄位

### 三種方式比較

#### 1. SERIAL（最常用，快速上手）
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);

-- 插入資料（id 自動生成）
INSERT INTO users (name) VALUES ('John');  -- id = 1
INSERT INTO users (name) VALUES ('Jane');  -- id = 2

-- 也可以手動指定 id
INSERT INTO users (id, name) VALUES (100, 'Bob');  -- id = 100
INSERT INTO users (name) VALUES ('Alice');  -- id = 101
```

#### 2. GENERATED ALWAYS AS IDENTITY（推薦，SQL 標準）
```sql
CREATE TABLE orders (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    product VARCHAR(50)
);

-- 只能自動生成，不可手動指定
INSERT INTO orders (product) VALUES ('Laptop');  -- ✓ id = 1
INSERT INTO orders (id, product) VALUES (999, 'Phone');  -- ✗ 錯誤！
```

#### 3. GENERATED BY DEFAULT AS IDENTITY（彈性最大）
```sql
CREATE TABLE logs (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    message TEXT
);

-- 可以自動生成
INSERT INTO logs (message) VALUES ('Log 1');  -- id = 1

-- 也可以手動指定
INSERT INTO logs (id, message) VALUES (999, 'Log 2');  -- id = 999

-- 下一個自動 id 會接續
INSERT INTO logs (message) VALUES ('Log 3');  -- id = 1000
```

### 快速對照表

| 特性 | SERIAL | GENERATED ALWAYS | GENERATED BY DEFAULT |
|------|--------|------------------|----------------------|
| 可手動指定 id | ✓ | ✗ | ✓ |
| SQL 標準 | ✗ | ✓ | ✓ |
| 推薦場景 | 一般使用 | 嚴格控制 | 需要手動控制 |

### 操作 SEQUENCE
```sql
-- 查看當前序列值
SELECT currval('users_id_seq');

-- 重設序列從 1 開始
ALTER SEQUENCE users_id_seq RESTART WITH 1;

-- 設定序列從指定值開始
ALTER SEQUENCE users_id_seq RESTART WITH 1000;
```

### 實用建議

- 新專案用 `GENERATED ALWAYS AS IDENTITY`（最標準）
- 快速開發用 `SERIAL`（最方便）
- 需要匯入舊資料用 `GENERATED BY DEFAULT`（保留原 id）

### 與 MySQL 的差異
```sql
-- MySQL
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);

-- PostgreSQL 等價寫法
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);
```

**重點：PostgreSQL 沒有 `AUTO_INCREMENT`，要用 `SERIAL` 或 `GENERATED AS IDENTITY`**

## ON DUPLICATE 的狀況

### UPSERT（插入或更新）語法差異

#### MySQL 寫法

**方法 1：ON DUPLICATE KEY UPDATE**
```sql
-- 當主鍵或唯一鍵衝突時，更新資料
INSERT INTO users (id, name, email, updated_at) 
VALUES (1, 'John', 'john@example.com', NOW())
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    email = VALUES(email),
    updated_at = NOW();

-- 使用 VALUES() 函數引用插入的值
INSERT INTO products (id, name, price, stock) 
VALUES (100, 'Laptop', 50000, 10)
ON DUPLICATE KEY UPDATE 
    price = VALUES(price),
    stock = stock + VALUES(stock);  -- 累加庫存
```

**方法 2：REPLACE INTO**
```sql
-- 刪除舊資料後重新插入（注意：會改變自增 id）
REPLACE INTO users (id, name, email)
VALUES (1, 'John', 'john@example.com');

-- 警告：這會觸發 DELETE 然後 INSERT
-- 相關的外鍵約束可能會受影響
```

#### PostgreSQL 寫法

**ON CONFLICT（更強大且靈活）**
```sql
-- 基本語法：指定衝突欄位
INSERT INTO users (id, name, email, updated_at) 
VALUES (1, 'John', 'john@example.com', NOW())
ON CONFLICT (id) 
DO UPDATE SET 
    name = EXCLUDED.name,
    email = EXCLUDED.email,
    updated_at = NOW();

-- 使用 EXCLUDED 引用要插入的值（類似 MySQL 的 VALUES()）
INSERT INTO products (id, name, price, stock) 
VALUES (100, 'Laptop', 50000, 10)
ON CONFLICT (id) 
DO UPDATE SET 
    price = EXCLUDED.price,
    stock = products.stock + EXCLUDED.stock;  -- 累加庫存
```

**指定唯一約束名稱**
```sql
-- 針對特定的唯一約束
INSERT INTO users (email, name) 
VALUES ('john@example.com', 'John')
ON CONFLICT ON CONSTRAINT users_email_key 
DO UPDATE SET 
    name = EXCLUDED.name,
    updated_at = NOW();
```

**條件式更新**
```sql
-- 只在特定條件下更新
INSERT INTO products (id, name, price, stock) 
VALUES (100, 'Laptop', 50000, 10)
ON CONFLICT (id) 
DO UPDATE SET 
    price = EXCLUDED.price,
    stock = EXCLUDED.stock
WHERE products.updated_at < NOW() - INTERVAL '1 day';
-- 只有當資料超過 1 天沒更新才執行更新
```

**忽略衝突**
```sql
-- 如果衝突就什麼都不做
INSERT INTO users (id, name, email) 
VALUES (1, 'John', 'john@example.com')
ON CONFLICT (id) 
DO NOTHING;
```

**多欄位唯一約束**
```sql
-- 當多個欄位組合為唯一鍵時
INSERT INTO user_roles (user_id, role_id, granted_at) 
VALUES (1, 5, NOW())
ON CONFLICT (user_id, role_id) 
DO UPDATE SET 
    granted_at = EXCLUDED.granted_at;
```

#### 實用範例對照

**範例 1：更新使用者資料**

MySQL:
```sql
INSERT INTO users (id, name, email, login_count) 
VALUES (1, 'John', 'john@example.com', 1)
ON DUPLICATE KEY UPDATE 
    email = VALUES(email),
    login_count = login_count + 1;
```

PostgreSQL:
```sql
INSERT INTO users (id, name, email, login_count) 
VALUES (1, 'John', 'john@example.com', 1)
ON CONFLICT (id) 
DO UPDATE SET 
    email = EXCLUDED.email,
    login_count = users.login_count + 1;
```

**範例 2：批次插入或更新**

MySQL:
```sql
INSERT INTO inventory (product_id, quantity) 
VALUES 
    (1, 10),
    (2, 20),
    (3, 30)
ON DUPLICATE KEY UPDATE 
    quantity = quantity + VALUES(quantity);
```

PostgreSQL:
```sql
INSERT INTO inventory (product_id, quantity) 
VALUES 
    (1, 10),
    (2, 20),
    (3, 30)
ON CONFLICT (product_id) 
DO UPDATE SET 
    quantity = inventory.quantity + EXCLUDED.quantity;
```

**範例 3：Email 唯一約束**

MySQL:
```sql
INSERT INTO users (email, name, created_at) 
VALUES ('john@example.com', 'John Doe', NOW())
ON DUPLICATE KEY UPDATE 
    name = VALUES(name);
```

PostgreSQL:
```sql
INSERT INTO users (email, name, created_at) 
VALUES ('john@example.com', 'John Doe', NOW())
ON CONFLICT (email) 
DO UPDATE SET 
    name = EXCLUDED.name;
```

#### 關鍵差異總結

| 特性 | MySQL | PostgreSQL |
|------|-------|-----------|
| 語法關鍵字 | `ON DUPLICATE KEY UPDATE` | `ON CONFLICT ... DO UPDATE` |
| 引用新值 | `VALUES(column)` | `EXCLUDED.column` |
| 引用舊值 | `column` 或 `table.column` | `table.column` |
| 指定衝突欄位 | 自動檢測所有唯一鍵 | 必須明確指定 `(column)` |
| 條件式更新 | ✗ 不支援 | ✓ 支援 `WHERE` 子句 |
| 忽略衝突 | 需用 `INSERT IGNORE` | `DO NOTHING` |
| 刪除後插入 | `REPLACE INTO` | ✗ 無對應語法（不推薦此模式） |

#### 重要提醒

**PostgreSQL 的優勢：**
- 必須明確指定衝突欄位，更清晰
- 支援條件式更新（`WHERE` 子句）
- `DO NOTHING` 語意更明確
- 不會像 `REPLACE INTO` 那樣刪除資料

**遷移注意事項：**
1. `VALUES(column)` → `EXCLUDED.column`
2. 必須指定 `ON CONFLICT (column_name)`
3. `REPLACE INTO` 沒有直接對應，需改用 `ON CONFLICT`
4. PostgreSQL 的 `ON CONFLICT` 更安全，不會刪除資料

#### 快速記憶
```sql
-- MySQL 模式
ON DUPLICATE KEY UPDATE col = VALUES(col)

-- PostgreSQL 模式
ON CONFLICT (id) DO UPDATE SET col = EXCLUDED.col
```

**關鍵字記憶：**
- MySQL: `VALUES()` = 要插入的新值
- PostgreSQL: `EXCLUDED.` = 要插入的新值