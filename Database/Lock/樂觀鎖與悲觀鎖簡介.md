---
tags:
  - lock
  - database
---
## What is `Lock`, why we need it

在多執行序同時存取相同資源的情況下，會因為沒辦法確定執行的先後順序而造成資料不一致，這就是常見的 `Race Condition`。而鎖就是解決他的方式。

## Terminology

- 悲觀鎖 - Pessimistic Lock
	- 假設資料會很常變動，為了保持資料的一致性，會在資料進行修改的時候加上鎖，不允許其他 transaction 來做改動。


- 樂觀鎖 - Optimistic Lock
	- 假設資料不常變動，所以不會對資料加上鎖，取而代之的是利用版本號來做檢查。當版本與當前資料相同時，代表自上一段時間開始，資料並`沒有被變更過`，所以可以直接進行修改。反之則代表`資料被變更過`，會需要進行重試。
	- 適合在==讀多寫少==的情況。


## Trade Off

就如同上面所提到的，悲觀鎖會在資料進行修改的時候加上 lock，來確保資料的一致性，但也因為加上 lock 的關係，導致每一個修改都只能一個一個來，在高併發的狀況下會導致效能低下。

既然上面的樂觀鎖只是單純用 version 去紀錄資料變化，依舊同時允許多個 request 對資料進行操作，又能達到資料一致性的效果，那為何不都用樂觀鎖就好了呢？

可以從以下例子來看

### 樂觀鎖

```java
// 樂觀鎖的運作方式
@Transactional
public String generate(LocalDate date) {
    // 1. 讀取 (不加鎖)
    TransactionSequence seq = repository.findById(date).orElse(...);
    
    // 2. 修改
    seq.setCurrentSeq(seq.getCurrentSeq() + 1);
    
    // 3. 寫入時檢查 version
    repository.save(seq);  // 如果 version 變了就失敗
}
```

**高併發時的表現:**
```
假設 100 個請求同時進來:

時間軸:
T1: 請求 1-100 都讀取到 currentSeq = 5, version = 1
T2: 請求 1-100 都計算出 nextSeq = 6
T3: 請求 1 先寫入成功 (version = 2)
T4: 請求 2-100 寫入失敗 (version 不匹配)
T5: 請求 2-100 重試...

結果:
- ✅ 99 個請求要重試
- ⚠️ 浪費了 99 次資料庫查詢
- ⚠️ 浪費了 99 次業務邏輯計算
- ⚠️ 可能造成重試風暴
```

### 悲觀鎖

```java
// 悲觀鎖 - 用 SELECT FOR UPDATE
@Transactional
public String generate(LocalDate date) {
    // 1. 讀取時就鎖住這筆記錄
    TransactionSequence seq = repository.findByIdForUpdate(date).orElse(...);
    // 其他請求會在這裡等待,直到鎖釋放
    
    // 2. 修改 (只有拿到鎖的請求能執行)
    seq.setCurrentSeq(seq.getCurrentSeq() + 1);
    
    // 3. 寫入 (一定成功,因為沒人能改)
    repository.save(seq);
    
    // 4. 交易結束,釋放鎖
}
```

**高併發時的表現:**
```
假設 100 個請求同時進來:

時間軸:
T1: 請求 1 拿到鎖,讀取 currentSeq = 5
T2: 請求 2-100 在資料庫層排隊等待
T3: 請求 1 寫入成功,釋放鎖
T4: 請求 2 拿到鎖,讀取 currentSeq = 6
T5: 請求 3-100 繼續等待
...

結果:
- ✅ 所有請求都成功,不用重試
- ✅ 每個請求只查詢一次資料庫
- ✅ 沒有浪費的計算
- ⚠️ 但是串行執行,吞吐量受限
```


從上面的狀況可以發現，在高併發的狀況下，樂觀鎖所造成的請求重試機率是非常高的。當大部分請求都會失敗，又會繼續 query db 進行重試的時候，相當於同時有許多請求打向 db，則會對 db *有極大的壓力*，反觀在這樣的狀況下，悲觀所因為一次只有一個 transaction 會去修改 db，即時在高併發的狀況下也能夠穩定資料庫的壓力。

## Summary 

在高併發流量下，當衝突率高的時候，選擇悲觀鎖可以有效的降低資料庫的壓力，但同時就會需要犧牲一點完成請求的效能。

在衝突率低的狀況下，選擇樂觀鎖可以在允許少量 retry 的狀況下，讓請求高併發執行，加速完成請求的效能。


## Reference

- [Optimistic vs. Pessimistic Locking in Databases | by Ivan Duhov | Medium](https://medium.com/@duhov/optimistic-vs-pessimistic-locking-in-databases-c32a52aeadfe)

- [理解資料庫『悲觀鎖』和『樂觀鎖』的觀念. 沒有經過實際操作的理論都只是空談，這篇文章我會附上自己的MySQL 語法… | by 林鼎淵 | Dean Lin | Medium](https://medium.com/dean-lin/%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E6%82%B2%E8%A7%80%E9%8E%96-vs-%E6%A8%82%E8%A7%80%E9%8E%96-2cabb858726d)