

## 微服務特性

1. 獨立部署
	- 微服務能夠在功能發布時獨立部署不受其他微服務影響，除了降低耦合程度，也能讓服務的迭代更方便。
2. 具備自己的資料
	- 各個微服務應該具備資料，即每個微服務有一顆屬於自己業務範圍內資料的 DB。若是 A 微服務需要 B 微服務的資料時，應透過 B 提供公開介面 (通常是 API) 進行存取。

>[!info]
>可以想像若是微服務之間共享資料庫，兩者彼此間針對資料庫進行改動時，就有可能間接的導致獨立部署變得困難


## Pros and Cons

### Pros
根據在 [微服務特性](##微服務特性) 中所提到的，既然微服務間能夠獨立進行部署，且是透過公開的介面彼此進行通訊的話，也就代表各個微服務之間能夠選擇不同的 tech stack 以更合適的方式去解決該業務範圍可能遇到的問題。**靈活性**可以說是~~拆分的好的~~微服務架構所具備最大的優勢。既能夠受惠於獨立部署而達成快速迭代，也能夠透過拆分的特性透過不同的技術解決不同領域的問題。

### Cons
既然整個應用程式架構是透過許多微服務組成，也意味著微服務之間的通訊會是一大問題，當遇到**延遲**或是**資料不一致**等問題時，處理上就會相對單體式系統來說更複雜。

## 單體式系統是什麼

書中大致將單體式系統分為三種

[單一程序的單體式系統](###單一程序的單體式系統)
[分散式單體式](###分散式單體式)
[第三方黑盒子](###第三方黑盒子)

### 單一程序的單體式系統

所有的程式碼都包含在單一程序中。也是作者看過許多人苦苦掙扎的類型，簡單來說就是一大包沒有經過好的拆分的系統(?)

既然有沒有拆分好的系統，那同也有能夠拆分好的單體式系統，在書中被稱為 **模組化單體式**，模組化單體式本身指的就是將功能切分好為各種不同的模組，各個模組之間同樣是獨立負責各自的領域內容，但在任一模組有變動時，同樣是整個系統都需要進行重新部署。

### 分散式單體式系統

書中認為的災難類型，具備了單體式與分散式系統的所有缺點，可以說是拆分微服務失敗的狀況。

舉例來說，因為各個單體式系統之間的邊界不夠明確，所以會造成進行單一功能修改的時可能就要改另外兩三個系統，徒增了系統的複雜性。

### 第三方黑盒子

由第三方所開發，我們無法直接對其進行修改，所以無法分解的系統。


### 單體式系統的挑戰

>當越來越多人在同一個地方工作時，他們就會開始互相妨礙，不同的開發人員會修改到同一段程式碼，或是不同團隊希望在不同時間發布功能。但因為是單體式系統的關係沒辦法分開進行部署


## 分割單體式系統

在理解現有程式碼之後，可以透過將單體式系統拆分成**模組化單體式**來解決問題，而作者也在書中提到，模組化單體式通常就可以解決大部分的問題。

若是以微服務為拆解目的，作者也推薦能夠透過 **漸進重寫** 的方式，先重寫現有的功能來優化程式碼，再重新實現功能到微服務上。有時候會發現重寫的過程中就能達到想要的效益，反而不需要微服務。當然，大部分以微服務為目標的團隊很少會執行這個重寫的流程，大多都會直接進行功能的實現。

## 遷移模式

### 絞殺榕

絞殺榕模式的概念並不複雜，主要是從舊的系統中提取出要拆解成微服務的部分，將其實現為微服務後，再將對舊系統的呼叫導向到抽離出來的微服務上。

這樣的好處在於，除了能夠替新系統(微服務)爭取時間來替換掉舊系統以外，也因為是漸進式的將功能慢慢以絞殺榕的方式來轉換成新的架構，透過漸進式的迭代也能夠降低遷移過程中複雜度。


>[!info]
>在絞殺榕模式中，作者提到了『部署』與『發行』是兩個概念。在抽離出新的微服務時，會先將其部署到生產環境中，但尚未發行交付給客戶做使用。這樣做的目的可以確保新功能的部署與管理流程，及在正式被使用前在正式環境進行驗證，等到確保新功能能夠達到與舊系統相同的效果時，即可將呼叫導向新功能所在的微服務。

#### Proxy

絞殺榕模式還能夠搭配 **proxy** 去統一攔截外部對單體式系統的呼叫，來讓遷移過程在做重導向的時候能夠更方便，不論是單純的 endpoint 重導向或是變更協定的重導向，都能夠透過 proxy 實現。

當隨著我們需要在 **proxy** 上使用越多的功能，可能進而使他變成越來越複雜使得部署迭代的速度會下降(因為一次部署牽涉的層面變廣)，因此在書中還有提到另外一種**服務網格(Service Mesh)** 的方式，透過每個微服務本身自己管理一個本地 proxy server，並透過一個統一的介面協調各個 proxy server，去降低單一 proxy server 帶來的複雜度。


### 使用者介面組成

透過將 UI 以相同功能類型區分模組，且隨著瀏覽器能實現的功能越來越複雜，**Micro Frontend** 的概念也被提出，讓同一個頁面也能夠使用不同的前端技術來完成。

### 抽象分支

當要提取的功能在系統深層時，我們可能會需要先對現有系統進行更改，以達到後續提取新功能的目的。而為了使程式碼變動對現有系統將到最低，這裡提出了**抽象分支** 的方式。

抽象分支在書中被拆解爲以下幾個步驟

1. 建立抽象
2. 使用抽象
3. 建立新實現
4. 切換實現
5. 清除

首先透過**建立抽象**，定義好各個針對當前系統的呼叫，接著**使用呼叫**，將呼叫轉向介面而非實現。而在這個時間點就可以透過**建立新實現**實作抽象。當新實現被驗證完成後，就可以透過**切換實現**轉換為新實現，最後**清除**舊實現。後續若要針對新功能提取微服務，就可以以新實現的狀況進行提取。

>[!info]
>切換實現的方式常會透過配置檔進行，而非直接進到程式碼中切換實作，以達到更輕鬆切換且方便部署的目的。

### 平行運作

平行運作相對於抽象分支只呼叫舊實現或是新實現的方式來說，是**兩者**一起呼叫，通常會以舊系統作為 single source of truth，以此來比較舊實現與新實現的差異，並透過修正逐步的同步新實現以達到我們所需要的效果。

書中提到的做法是透過複製請求的方式，一部分給舊實現，一部分給新實現。兩者各自都會**接收所有請求**

>[!info]
>平行運作不同於傳統上的金絲雀釋出(Canary Release) ，Canary Release 是將部分使用者引導至新功能，即時新功能出錯也只有一部分請求受到影響。但他們都是透過漸進式交付的方式來迭代軟體，減少一次大更動帶來的深遠影響。

### 裝飾合作者

在現有系統難以更改的情況下，可以透過裝飾者模式進行來處理。

透過 proxy server 攔截單體式系統的 response，將這個 response 作為微服務的 request，以達到在不更動現有系統但能夠新增功能的方式。但要避免 **dump pipe** 的狀況

### 變更資料截取

在不修改(或無法修改)當前系統的狀況下，且又無法套用裝飾者模式的時候，可能就得採取變更資料截取的方式。透過像是 store procedure 在資料庫的 table 有變動時觸發去呼叫某個微服務，或是透過 polling 的方式定期從 audit table 定期撈取變動的資料，但要避免系統架構與資料庫太過耦合。

## Reference 

[《單體式系統到微服務》讀後分享 - 上](https://yuanchieh.page/posts/2021/2021-12-03-%E5%96%AE%E9%AB%94%E5%BC%8F%E7%B3%BB%E7%B5%B1%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8B%99%E8%AE%80%E5%BE%8C%E5%88%86%E4%BA%AB-%E4%B8%8A/)

[《單體式系統到微服務》讀後分享 - 下](https://yuanchieh.page/posts/2021/2021-12-05-%E5%96%AE%E9%AB%94%E5%BC%8F%E7%B3%BB%E7%B5%B1%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8B%99%E8%AE%80%E5%BE%8C%E5%88%86%E4%BA%AB-%E4%B8%8B/)

[微服務架構 #1, WHY Microservices? — 安德魯的部落格](https://columns.chicken-house.net/2016/09/15/microservice-case-study-01/)